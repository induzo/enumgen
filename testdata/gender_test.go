// Code generated by github.com/induzo/enumgen DO NOT EDIT.
package book

import (
	"errors"
	"reflect"
	"testing"
)

func TestGender_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		payload []byte
		wantErr bool
	}{
		{
			name:    "correct",
			payload: []byte(`"male"`),
			wantErr: false,
		},
		{
			name:    "correct",
			payload: []byte(`"female"`),
			wantErr: false,
		},
		{
			name:    "correct",
			payload: []byte(`"other"`),
			wantErr: false,
		},
		{
			name:    "error parsing",
			payload: []byte(`"xxx"`),
			wantErr: true,
		},
		{
			name:    "error unmarshalling",
			payload: []byte(`{}`),
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var g Gender
			if err := g.UnmarshalJSON(tt.payload); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMustParseGenderFromString(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		chRes   string
		want    Gender
		wantErr bool
	}{
		{
			name:  "correct male",
			chRes: "male",
			want:  GenderMale,
		},
		{
			name:  "correct female",
			chRes: "female",
			want:  GenderFemale,
		},
		{
			name:  "correct other",
			chRes: "other",
			want:  GenderOther,
		},
		{
			name:    "error",
			chRes:   "xxx",
			want:    "",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if tt.wantErr {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("The code did not panic")
					}
				}()

				MustParseGenderFromString(tt.chRes)

				return
			}

			got := MustParseGenderFromString(tt.chRes)
			if got != tt.want {
				t.Errorf("MustParseFromString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGender_MarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		chRes   Gender
		want    []byte
		wantErr bool
	}{
		{
			name:  "male",
			chRes: GenderMale,
			want:  []byte(`"male"`),
		},
		{
			name:  "female",
			chRes: GenderFemale,
			want:  []byte(`"female"`),
		},
		{
			name:  "other",
			chRes: GenderOther,
			want:  []byte(`"other"`),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := tt.chRes.MarshalJSON()
			if (err != nil) != tt.wantErr {
				t.Errorf("MarshalJSON() error = %v, wantErr %v", err, tt.wantErr)

				return
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MarshalJSON() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnmarshalGenderError_Error(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		Data string
		Err  error
		want string
	}{
		{
			name: "correct",
			Data: "data",
			Err:  nil,
			want: "error parsing Gender `data`: <nil>",
		},
		{
			name: "correct",
			Data: "data",
			Err:  errors.New("error"),
			want: "error parsing Gender `data`: error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			e := UnmarshalGenderError{
				Data: tt.Data,
				Err:  tt.Err,
			}

			if got := e.Error(); got != tt.want {
				t.Errorf("UnmarshalGenderError.Error() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenderParseError_Error(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		Gender string
		want   string
	}{
		{
			name:   "correct",
			Gender: "data",
			want:   "invalid Gender value: data",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			e := GenderParseError{
				Gender: tt.Gender,
			}

			if got := e.Error(); got != tt.want {
				t.Errorf("GenderParseError.Error() = %v, want %v", got, tt.want)
			}
		})
	}
}
